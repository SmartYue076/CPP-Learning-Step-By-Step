## 第二章 C++基础——指针

指针是一个变量，其存储的是值的地址，而不是值本身

使用常规变量时，值是指定的量，而地址是派生量，而指针相反

*OOP*强调的是在运行阶段（而不是编译阶段）进行决策，提供了灵活性，对于内存管理也更加高效

### 初始化指针

```c++
int* ptr_a;
double* ptr_b;
```
初始化时必须指定所指元素类型，因为对所有指针来说其都是代表一个初始地址，但从该初始地址读多少字节则由指针类型判断

指针也是作为变量存储，只不过其内存空间存的是地址。指针p1,p2有各自的地址&p1,&p2。长度为4B（32位）或8B（64位）。p1,p2表示存储的所指向元素的地址。*p1表示指向元素的值。
<img src="..\img\1.PNG" alt="image.png" style="zoom:30%;" />



### 指针注意事项

在C++中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存（指向不确定）。另外，**一定要在对指针提取（*）之前，将指针初始化为一个确定的、适当的地址。**

一个未指向任何对象的指针，其地址值为0。有时称之为`null指针`。任何指针都可以被初始化或令其值为0。

指针不是整型，虽然计算机通常把地址当作整数处理。

```C++
int* pt;
pt = 0xB80000000; //invalid, type mismatch
pt = (int*)0xB80000000; //valid, type match
```


### 指针和数组

可以修改指针的值，但数组名是常量不能修改

指针变量加1后，其增加的值等于指向的类型占用的字节数

将一个指针减去另一个指针，获得两个指针的差（必须类型相同，差为地址实际差/变量类型长度），仅在都指向同一数组时有意义

对数组应用sizeof得到的是数组的长度，而对指针应用sizeof得到的是指针的长度

#### 数组指针与指针数组

  tell和&tell数值相同，但tell指向数组第一个元素，tell+1将地址值加2。&tell指向整个数组，&tell+1将地址值加2*10=20

  ```C++
  short tell[10];
  cout<< tell <<endl;
  cout<< &tell <<endl;
  ```

  数组指针指向整个数组，初始化为

  ```C++
  short (*pas)[10] = &tell;
  ```

  指针数组为多个指针变量组成的数组，初始化为

  ```C++
  short *pas[10];
  ```


### 自由存储空间

#### 使用new来分配内存

```c++
//typeName * pointer_name = new typeName
int* pn = new int;
```

```new```运算符根据类型来确定需要多少字节的内存，找到这样的内存并返回

```typeName*```指声明什么类型的指针，左右两侧的类型必须相同，否则因为读取的块大小不同而访问错误

**变量存储在栈（stack）的内存区域中，new从堆（heap）或自由存储（free store）的内存区域分配内存**



#### 使用delete释放内存

```c++
int* ps = new int;
delete ps;
```

这将删除*ps*所指向的内存，但不会删除*ps*本身，ps还可指向其他内存空间

需要注意的是：

- 不要使用```delete```来释放不是```new```分配的内存
- 不要使用```delete```释放同一个内存两次
- 对空指针(*null pointer*)使用```delete```是安全的



#### 使用new创建动态数组

```c++
int* psome = new int [10];
delete [] psome;
```

数组直接通过```psome[num]```访问

需要注意的是：

- 如果使用```new [] ```为数组分配内存，则需要通过```delete []```来释放
- 如果使用```new```为一个实体分配内存，则应使用```delete```来释放



### 复杂表达式

对于复杂表达式应从右往左读

`int *&r = p`

表示r首先是对p的引用，其次r是一个int*型的引用